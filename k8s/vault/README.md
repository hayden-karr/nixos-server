
# Vault - HashiCorp Vault for Secrets Management

Secrets management for Kubernetes. Vault stores and controls access to secrets like API keys, passwords, and certificates.

## Why Vault?

**Problem:** Storing secrets in Git, ConfigMaps, or environment variables is insecure and doesn't scale.

**Solution:** Vault provides centralized secrets management with:

- Encryption at rest and in transit
- Access control via policies
- Audit logging of all secret access
- Dynamic secrets with automatic rotation
- AppRole authentication for applications

## Architecture

- **Storage**: File-based backend (single-node)
- **Authentication**: AppRole for service-to-service auth
- **Secrets Engines**: KV v2 (versioned key-value store)
- **High Availability**: Single replica (HA possible with Raft/Consul backend)

## Initial Setup

**1. Deploy Vault via ArgoCD**:

```bash
kubectl apply -f k8s/argocd/vault-app.yaml
```

**2. Wait for pod to be running**:

```bash
kubectl get pods -n vault -w
```

**3. Initialize Vault** (one-time only):

```bash
kubectl exec -it vault-0 -n vault -- vault operator init
```

This outputs:

- 5 unseal keys (store securely - need 3 to unseal)
- 1 root token (store securely - needed for configuration)

Save the unseal keys and root token in a password manager. If you lose them, you cannot access Vault.

**4. Unseal Vault** (required after every restart):

```bash
# Run this 3 times with different keys
kubectl exec -it vault-0 -n vault -- vault operator unseal
# Paste unseal key when prompted
```

**5. Configure Vault with OpenTofu** (Infrastructure-as-Code):

```bash
cd terraform/vault
export VAULT_TOKEN="<root-token>"
tofu init
tofu apply
```

This creates:

- AppRole authentication backend
- KV v2 secrets engines
- Random secrets
- AppRole policy and role
- Outputs AppRole credentials for ESO

Vault accessible at `http://localhost:30820` via NodePort. See `terraform/vault/README.md` for details.

## Unsealing After Restarts

Vault seals automatically when:

- Pod restarts (crash, update, node drain)
- Kubernetes node reboots
- Manual seal operation

To unseal, run the unseal command 3 times with different keys:

```bash
kubectl exec -it vault-0 -n vault -- vault operator unseal
```

**Why manual unsealing?**

- Security: Prevents automatic access to secrets if the server is compromised
- Auto-unseal exists (using cloud KMS) but is overkill for homelab
- Manual unseal is acceptable for non-production environments

## Vault in Rootless K3s

**mlock disabled**: Rootless containers can't lock memory to prevent swapping secrets to disk. This is a known limitation of rootless mode and is acceptable for homelab/dev environments.

**Security hardening**:

- Read-only root filesystem
- Non-root user (UID 100)
- No privilege escalation
- Minimal capabilities (IPC_LOCK added but not effective)
- TLS disabled (internal cluster communication only)

## Integration with External Secrets Operator

Vault doesn't directly create Kubernetes Secrets. Instead:

1. **Vault** - Stores secrets
2. **AppRole** - Authenticates applications
3. **ESO (External Secrets Operator)** - Syncs secrets from Vault → Kubernetes
4. **Pods** - Reference standard Kubernetes Secrets

See `k8s/immich-friend/README.md` for ESO setup.

## Monitoring

```bash
# Check Vault status
kubectl exec -it vault-0 -n vault -- vault status

# Check logs
kubectl logs -n vault vault-0 -f

# Port-forward to access UI (maps container port 8200 to localhost:8300)
kubectl port-forward -n vault vault-0 8300:8200
# Visit http://localhost:8300
# Note: LoadBalancer service already exposes at host:8300 (no port-forward needed)
```

## Production Considerations

**Current setup** is suitable for homelab, development environments, and single-node deployments.

**For production**, consider:

- **HA deployment** - Raft or Consul backend with 3+ replicas
- **Auto-unseal** - Cloud KMS (AWS KMS, Azure Key Vault, GCP KMS)
- **TLS** - Enable TLS for external access
- **Backup strategy** - Regular backups of Vault data
- **Monitoring** - Prometheus metrics and alerting
- **Disaster recovery** - Documented recovery procedures

## Secrets Stored

Vault stores these secrets for immich-friend:

- `immich-friend/database` → PostgreSQL password (auto-generated, 32 chars)
- `immich-friend/oauth` → OAuth client secret (auto-generated, 32 chars)
- `immich-friend/jwt` → JWT signing secret (auto-generated, 64 chars)
- `immich-friend/session` → Session encryption secret (auto-generated, 32 chars)
- `immich-friend/storage` → Storage encryption key (auto-generated, 32 chars)
- `immich-friend/oidc-hmac` → OIDC HMAC secret (auto-generated, 32 chars)
- `resend/api` → Email service API key (set manually or via OpenTofu variable)

Secrets auto-generated by OpenTofu.

## Troubleshooting

**Pod stuck in CrashLoopBackOff**:

- Vault is likely sealed - check with `vault status`
- Unseal with 3 keys

**"connection refused" errors**:

- Vault pod not running - check with `kubectl get pods -n vault`
- Vault sealed - unseal with keys

**Liveness probe failures**:

- Normal if Vault is sealed or uninitialized
- Liveness probe accepts sealed (204) and uninitialized (204) states

**AppRole authentication failures**:

- Verify vault-approle secret exists in target namespace
- Check SecretStore configuration in ExternalSecret manifests
